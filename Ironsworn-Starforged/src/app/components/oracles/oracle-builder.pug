include ../moves/mixins/move-builder

mixin oracleLabel(type, name, id)
  label.toggle-btn.oracle-btn
    input.hide-element.btn-input(
      type='radio'
      title=`@{oracle_${type}_button}`
      name=`attr_oracle_${type}_button`
      value=id
    )
    .btn-content.oracle-name=header

mixin oracleRowBuilder(table, row, index)
  -
    function rangeString(initChance, finalChance) {
      return (initChance === finalChance) ? finalChance : `${initChance}-${finalChance}`;
    };
    function resultString(row) {
      let detailsKeys = ["Assets", "Details"];
      let detailsStrings = [];
      detailsKeys.forEach(key => {
        if (row[key]) {
          if (key === "Assets") {
            row[key] = row[key].map(item => item.toUpperCase());
          }
          detailsStrings.push(row[key])
        };
      });
      let detailString;
      if (detailsStrings.length > 0) {
        detailsStrings = detailsStrings.flat(2);
        detailString = `(${detailsStrings.join(", ")})`;
      };
      const result = `${row.Description}${detailString ? " " + detailString : ""}`;
      return result;
    }
      let ranges = [];
    if (Array.isArray(row.Chance)) {
      row.Chance.forEach((chance, chanceIndex) => {
        if (chance === 0) {
          ranges.push(`&mdash;`)
        }
        else
        {const initChance = (index === 0) ? chance - (chance - 1) : table[index - 1].Chance[chanceIndex] + 1;
        const finalChance = chance;
        ranges.push(rangeString(initChance, finalChance));}
      })
    }
    else {
      const initChance = (index === 0) ? row.Chance - (row.Chance - 1) : table[index - 1].Chance + 1;
      const finalChance = row.Chance;
      ranges.push(rangeString(initChance, finalChance));
    }
  tr.oracle-row
    each range in ranges
      td.oracle-roll=range
    td.oracle-result=resultString(row)

mixin oracleRollGroup(group)
  //- TODO: implement as details/summary?
  .oracle-box
    .oracle-title=group.Name
    each oracle in group.Oracles
      - const header = `${group.Name} - ${oracle.Name}`
      .oracle
        if (oracle.Tables)
          - let buttonLabel = oracle.Name
          +oracleButtonMultiTables(oracle.id, buttonLabel, oracle.Tables)
        else
          +oracleButton(oracle.id, oracle.Name)
    if group.Subcategories
      each subCategory in group.Subcategories
        - const buttonLabel = subCategory.Name||subCategory['Display name']
        .oracle.oracle-subcategory
          +oracleButtonMultiTables(subCategory.id, buttonLabel, subCategory.Oracles)

mixin oracleButtonSingleTable(id, buttonLabel)
  +oracleButton(id, buttonLabel)

mixin oracleButtonMultiTables(id, buttonLabel, tables, indexOffset=0)
  //- indexOffset is to handle subtables within subcategories
  -
    let counter = 0;
    let options = [];
    tables.forEach((oracle) => {
      if (oracle.Tables) {
        oracle.Tables.forEach(subtable => {
          let tableLabel = subtable['Display name']||subtable['Name'];
          options.push(`${tableLabel},${counter}`);
          counter++;
        })
      }
      else {
        let tableLabel = oracle['Display name']||oracle['Name'];
        options.push(`${tableLabel},${counter}`);
        counter++;
      }
    })
  - const rollQuery = `{{tableChoice=[[(?{Choose Table|${options.join('|')}})]]}}`
  +oracleButton(id, buttonLabel, rollQuery)

mixin oracleButton(id, buttonLabel, rollQuery="")
  //- generates CSS
  //- - console.log(`input[type=radio].${id}:checked ~ div.${id},`)
  -
    let valueString = `&{template:starforged_oracles} ${rollQuery} {{${id}=[[d100]]}}`;
    if (!rollQuery.match(/header=/i)) {
      valueString = valueString + " " +  `{{header=${buttonLabel}}}`
    }
  .button-container
    button(
      type='roll'
      class='oracle-roll'
      title=`@{roll_${id}}`
      name=`roll_${id}`
      value=valueString
    )
  label.toggle-btn.oracle-btn
    input.hide-element.btn-input(
      type='radio'
      title=`@{selected_oracle}`
      name=`attr_selected_oracle`
      value=id
    )
    .btn-content.oracle-name=buttonLabel

mixin oracleTableBuilder(oracle, titleText)
  table.oracle-table.oracle-table-preview(id=oracle.id)
    thead
      th.oracle-title.oracle-table-preview(colspan=2)=titleText
    each row, index in oracle.Table
      +oracleRowBuilder(oracle.Table, row, index)

mixin oracleSubTableBuilder(subtable, subtitleText)
  table.oracle-table.oracle-subtable
    thead
      th.oracle-subtitle(colspan=2)=subtitleText
    each row, index in subtable.Table
      +oracleRowBuilder(subtable.Table, row, index)

mixin oracleSubTableMultiBuilder(oracle, titleText)
  //-  builds tables with multiple Roll columns, e.g. regional tables
  -
    let mergedRows = [];
    //- if all subtables have the same number of rows
    if (oracle.Tables.every(subtable =>
      subtable.Table.length == oracle.Tables[0].Table.length
      //- && subtable.Table.map(row => row.Description) == oracle.Tables[0].Table.map(row => row.Description)
    )) {
      console.log("oracleSubTableMultiBuilder: all tables of", oracle.Name, "have the same length.");
      oracle.Tables[0].Table.forEach((row, index) => {
        let newRow = _.clone(row);
        newRow.Chance = [];
        oracle.Tables.forEach(subOracle => newRow.Chance.push(subOracle.Table[index].Chance));
        mergedRows.push(newRow);
      })
    } else {
      let tables = oracle.Tables.map(subtable => subtable.Table);
      console.log("oracleSubTableMultiBuilder: tables of", oracle.Name, "have different lengths -",  tables.map(item => item.length).join(", "));
      let baseTable = _.clone(tables.reduce((a, b) => a.length > b.length ? a : b));
      //- console.log("longest table will act as base:", baseTable);
      // selects longest table as starting point
      baseTable.forEach((row) => {
        let newRow = _.clone(row);
        newRow.Chance = [];
        tables.forEach(tbl => {
          if (!_.isUndefined(tbl.find(tblRow => tblRow.Description === row.Description)))
          {
            matchingRow = _.clone(tbl.find(
                tblRow => tblRow.Description === row.Description
              ));

            newRow.Chance.push(matchingRow.Chance);
          }
          else {
            newRow.Chance.push(0);
          }
        })
        mergedRows.push(newRow);
      })
    }
  if oracle.Description
    p.oracle-description=oracle.Description
  table.oracle-table.oracle-subtable.oracle-subtable-multi
    thead
      tr
        th.oracle-subtitle(colspan=(oracle.Tables.length+1))=titleText
      tr
        each subOracle in oracle.Tables
          th.oracle-column-head=subOracle.Name
        th.oracle-column-head=`Result`
    each row, index in mergedRows
      +oracleRowBuilder(mergedRows, row, index)


mixin oracleBuilder(oracle, groupName)
  //- - console.log("oraclebuilder in", groupName)
  input(class=`${oracle.id} hide-element` type='radio' name=`attr_oracle_preview` value=oracle.id)
  div(class=`${oracle.id} showhide`)
    if oracle.Table
      +oracleTableBuilder(oracle, `${groupName} - ${oracle.Name}`)
    else if oracle.Tables
      .oracle-title.oracle-table-preview=`${groupName} - ${oracle.Name}`
      +oracleSubTableMultiBuilder(oracle)
      //- each subtable, index in oracle.Tables
        //- +oracleSubTableBuilder(subtable, subtable['Display name']||subtable['Name'])
    else if oracle.Oracles
      .oracle-title.oracle-table-preview=`${groupName} - ${oracle.Name}`
      each subCatOracle, index in oracle.Oracles
        if subCatOracle.Table
          +oracleSubTableBuilder(subCatOracle, subCatOracle['Display name']||subCatOracle['Name'])
        else if subCatOracle.Tables
          +oracleSubTableMultiBuilder(subCatOracle, subCatOracle.Name)
          //- each subtable, index in subCatOracle.Tables
            //- +oracleSubTableBuilder(subtable, subtable['Display name']||subtable['Name'])

        //- - console.log("NYI: found subcategories", oracle.Oracles.map(str => str.Name).join(", ") )